大圈套小圈思想
for循环嵌套外循环控制行数内循环控制一行中的个数
syso换行
加入一个变量或者可能可以用外循环的那个变量改变内循环的个数可以通过改变判断条件或者初始条件的大小(动态变化)
转译字符\对后面的字符转译2个反斜线会变成一个无转译意义的\
\n回车符用在字符串中在任意位置换行
\t制表符tab键固定切换到固定的格子中类似表格帮你做格式
\b退格
\r按下回车键
window系统中回车符其实是由两个符号组成\r\n组成
linux系统中回车符是\n
等腰三角形可能是由空格填充的有2个内循环1个输出空格1个输出星星
break跳出
作用的范围要么是switch要么是循环结构
break语句单独存在时下面不要定义其他语句因为执行不到
break不是跳if是跳循环
break跳出当前循环，如果出现循环嵌套那break想要跳出制定的循环可以通过标号来完成
xiaoqiang:for(;;){
wangcai:for(;;){
syso;
breakxiaoqiang;//跳出外层循环
}
}
continue:继续
作用的范围:循环结构
continue回到循环的循环后的操作表达式
结束本次循环，继续下次循环
如果continue单独存在时下面不要有任何语句，因为执行不到。注意单独
在java中被赋予了特殊的含义叫关键字
函数有独立的功能因为他有独立的区间
修饰符返回值类型函数名(参数类型形式参数1，参数类型形式参数2)｛
执行语句;
return返回语句;
｝
特殊情况
功能没有具体的返回值
return后面直接用封号结束因为没有具体值所以不可以写具体的数据类型java只能用一个关键字void来表示
如果返回值类型是void那么函数中的return可以省略不写，写上也没事
代码重复出现的话可以立一个函数提高复用性
函数级别是同级的
函数的结果返还给调用者
函数要明确：1、这个功能的结果是什么2、这个功能的实现过程中是否需要未知内容参与运算
参数类型和返回值类型无关
行row列column
ifelse和三元运算符区别三元运算符一定要返回一个结果
(形参)作用域
cmd中输入java时启动java虚拟机帮你运行java程序
主函数先进栈到栈底先进后出
函数执行完后被释放
overload重载
在同一个类中允许存在一个一上的同名函数只要他的参数个数或参数类型不同即可
函数的重载和函数返回值类型无关Java是严谨性语言如果函数的调用不确定性就不能通过编译
重载中有些可以调用覆盖范围比较大的函数来实现小的
同一类型的数据的集合数组就是个容器
数组从0开始编号
元素类型[]数组名=new元素类型[元素个数或数组长度];
数据默认为0
jvmqq之类启动时要进行区域内存划分
jvm内部也有不同的区域管理
有5个区域1、寄存器2、本地方法区3、方法区4、栈内存5、堆内存
栈内存存储的都是局部变量(凡是定义在方法中的变量都是局部变量)而且变量所属的作用域一旦结束，该变量就自动释放方法进栈局部变量才能进栈
变量都有其作用域一旦离开作用域就会被释放栈没有初始化值
主函数中没有名字的大括号(封装区域)叫局部代码块可以用来限定局部变量的生命周期
堆内存存储的是数组和对象(其实数组就是对象)凡是new建立在堆中通过new开辟一个空间内存地址就是一串连续二进制进制越大表现形式越短所以用16进制
堆的特点:1、每一个实体都有首地址值2、对内存的每一个变量都有默认初始化值，根据类型不同而不同，整数是0，char‘\u0000’
float0.0fbooleanfalse3、垃圾回收机制\u表示unicode编码表
基本数据类型把数据存储在变量中数组引用(指向)了堆内存中的数据通过地址值进行操作
null能取消地址的指向后arr变成了垃圾通过析构函数进行自动随机回收JAVA在内存的管理优于C++
有new在堆中重新分配空间分配地址然后默认初始化再地址值赋给变量变量通过地址指向堆内存的空间
数组关注地址值多个引用能指向同一个地址值
int[]arr=newint[3];
syso("arr[3]")ArrayIndexOutOfBoundsException当访问到数组中不存在的角标时发生该异常
编译时不找角标
当引用型变量没有任何实体指向时，还在用其操作实体就会发生NoPointerException空指针异常
通过哈希算法来算在内存中的地址值[i@c4545一半中括号是数组左边知道是int类型的数组右侧16进制调用WINDOWS的哈希算法

